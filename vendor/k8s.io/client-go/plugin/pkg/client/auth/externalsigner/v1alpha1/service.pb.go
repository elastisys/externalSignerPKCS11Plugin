/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: service.proto

package v1alpha1

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Version int32

const (
	Version_v1alpha1 Version = 0
)

var Version_name = map[int32]string{
	0: "v1alpha1",
}

var Version_value = map[string]int32{
	"v1alpha1": 0,
}

func (x Version) String() string {
	return proto.EnumName(Version_name, int32(x))
}

func (Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{0}
}

type VersionRequest struct {
	// Version of the external signer plugin API.
	Version              Version  `protobuf:"varint,1,opt,name=version,proto3,enum=v1alpha1.Version" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionRequest) Reset()         { *m = VersionRequest{} }
func (m *VersionRequest) String() string { return proto.CompactTextString(m) }
func (*VersionRequest) ProtoMessage()    {}
func (*VersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{0}
}
func (m *VersionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionRequest.Unmarshal(m, b)
}
func (m *VersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionRequest.Marshal(b, m, deterministic)
}
func (m *VersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionRequest.Merge(m, src)
}
func (m *VersionRequest) XXX_Size() int {
	return xxx_messageInfo_VersionRequest.Size(m)
}
func (m *VersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VersionRequest proto.InternalMessageInfo

func (m *VersionRequest) GetVersion() Version {
	if m != nil {
		return m.Version
	}
	return Version_v1alpha1
}

type VersionResponse struct {
	// Version of the external signer plugin API.
	Version              Version  `protobuf:"varint,1,opt,name=version,proto3,enum=v1alpha1.Version" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionResponse) Reset()         { *m = VersionResponse{} }
func (m *VersionResponse) String() string { return proto.CompactTextString(m) }
func (*VersionResponse) ProtoMessage()    {}
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{1}
}
func (m *VersionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionResponse.Unmarshal(m, b)
}
func (m *VersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionResponse.Marshal(b, m, deterministic)
}
func (m *VersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionResponse.Merge(m, src)
}
func (m *VersionResponse) XXX_Size() int {
	return xxx_messageInfo_VersionResponse.Size(m)
}
func (m *VersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VersionResponse proto.InternalMessageInfo

func (m *VersionResponse) GetVersion() Version {
	if m != nil {
		return m.Version
	}
	return Version_v1alpha1
}

// Cluster contains information to allow an exec plugin to communicate with the
// kubernetes cluster being authenticated to.
type Cluster struct {
	// Server is the address of the kubernetes cluster (https://hostname:port).
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// ServerName is passed to the server for SNI and is used in the client to
	// check server certificates against. If ServerName is empty, the hostname
	// used to contact the server is used.
	ServerName string `protobuf:"bytes,2,opt,name=serverName,proto3" json:"serverName,omitempty"`
	// CAData contains PEM-encoded certificate authority certificates.
	// If empty, system roots should be used.
	CaData []byte `protobuf:"bytes,3,opt,name=caData,proto3" json:"caData,omitempty"`
	// Config holds additional config data that is specific to the exec plugin
	// with regards to the cluster being authenticated to.
	Config               []byte   `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{2}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Cluster.Unmarshal(m, b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return xxx_messageInfo_Cluster.Size(m)
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *Cluster) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *Cluster) GetCaData() []byte {
	if m != nil {
		return m.CaData
	}
	return nil
}

func (m *Cluster) GetConfig() []byte {
	if m != nil {
		return m.Config
	}
	return nil
}

type CertificateRequest struct {
	// Version of the external signer plugin API.
	Version Version `protobuf:"varint,1,opt,name=version,proto3,enum=v1alpha1.Version" json:"version,omitempty"`
	// Cluster information.
	Cluster *Cluster `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// Configuration of the external signer plugin. This configuration is specific to the external signer, but stored in KUBECONFIG for the user's convenience to allow multiplexing a single external signer for several K8s users.
	Configuration        map[string]string `protobuf:"bytes,3,rep,name=configuration,proto3" json:"configuration,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CertificateRequest) Reset()         { *m = CertificateRequest{} }
func (m *CertificateRequest) String() string { return proto.CompactTextString(m) }
func (*CertificateRequest) ProtoMessage()    {}
func (*CertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{3}
}
func (m *CertificateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateRequest.Unmarshal(m, b)
}
func (m *CertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateRequest.Marshal(b, m, deterministic)
}
func (m *CertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateRequest.Merge(m, src)
}
func (m *CertificateRequest) XXX_Size() int {
	return xxx_messageInfo_CertificateRequest.Size(m)
}
func (m *CertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateRequest proto.InternalMessageInfo

func (m *CertificateRequest) GetVersion() Version {
	if m != nil {
		return m.Version
	}
	return Version_v1alpha1
}

func (m *CertificateRequest) GetCluster() *Cluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *CertificateRequest) GetConfiguration() map[string]string {
	if m != nil {
		return m.Configuration
	}
	return nil
}

type CertificateResponse struct {
	// Types that are valid to be assigned to Content:
	//	*CertificateResponse_Certificate
	//	*CertificateResponse_UserPrompt
	Content              isCertificateResponse_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *CertificateResponse) Reset()         { *m = CertificateResponse{} }
func (m *CertificateResponse) String() string { return proto.CompactTextString(m) }
func (*CertificateResponse) ProtoMessage()    {}
func (*CertificateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{4}
}
func (m *CertificateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateResponse.Unmarshal(m, b)
}
func (m *CertificateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateResponse.Marshal(b, m, deterministic)
}
func (m *CertificateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateResponse.Merge(m, src)
}
func (m *CertificateResponse) XXX_Size() int {
	return xxx_messageInfo_CertificateResponse.Size(m)
}
func (m *CertificateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateResponse proto.InternalMessageInfo

type isCertificateResponse_Content interface {
	isCertificateResponse_Content()
}

type CertificateResponse_Certificate struct {
	Certificate []byte `protobuf:"bytes,1,opt,name=certificate,proto3,oneof" json:"certificate,omitempty"`
}
type CertificateResponse_UserPrompt struct {
	UserPrompt string `protobuf:"bytes,2,opt,name=userPrompt,proto3,oneof" json:"userPrompt,omitempty"`
}

func (*CertificateResponse_Certificate) isCertificateResponse_Content() {}
func (*CertificateResponse_UserPrompt) isCertificateResponse_Content()  {}

func (m *CertificateResponse) GetContent() isCertificateResponse_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *CertificateResponse) GetCertificate() []byte {
	if x, ok := m.GetContent().(*CertificateResponse_Certificate); ok {
		return x.Certificate
	}
	return nil
}

func (m *CertificateResponse) GetUserPrompt() string {
	if x, ok := m.GetContent().(*CertificateResponse_UserPrompt); ok {
		return x.UserPrompt
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CertificateResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CertificateResponse_Certificate)(nil),
		(*CertificateResponse_UserPrompt)(nil),
	}
}

type SignatureRequest struct {
	// Version of the external signer plugin API.
	Version Version `protobuf:"varint,1,opt,name=version,proto3,enum=v1alpha1.Version" json:"version,omitempty"`
	// Cluster information.
	Cluster *Cluster `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// Configuration of the external signer plugin (HSM protocol specific).
	Configuration map[string]string `protobuf:"bytes,3,rep,name=configuration,proto3" json:"configuration,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Digest to be signed.
	Digest []byte `protobuf:"bytes,4,opt,name=digest,proto3" json:"digest,omitempty"`
	// Options for creating the signature.
	//
	// Types that are valid to be assigned to SignerOpts:
	//	*SignatureRequest_SignerOptsRSAPKCS1
	//	*SignatureRequest_SignerOptsRSAPSS
	//	*SignatureRequest_SignerOptsECDSA
	//	*SignatureRequest_SignerOptsED25519
	SignerOpts           isSignatureRequest_SignerOpts `protobuf_oneof:"signerOpts"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *SignatureRequest) Reset()         { *m = SignatureRequest{} }
func (m *SignatureRequest) String() string { return proto.CompactTextString(m) }
func (*SignatureRequest) ProtoMessage()    {}
func (*SignatureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{5}
}
func (m *SignatureRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureRequest.Unmarshal(m, b)
}
func (m *SignatureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureRequest.Marshal(b, m, deterministic)
}
func (m *SignatureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureRequest.Merge(m, src)
}
func (m *SignatureRequest) XXX_Size() int {
	return xxx_messageInfo_SignatureRequest.Size(m)
}
func (m *SignatureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureRequest proto.InternalMessageInfo

type isSignatureRequest_SignerOpts interface {
	isSignatureRequest_SignerOpts()
}

type SignatureRequest_SignerOptsRSAPKCS1 struct {
	SignerOptsRSAPKCS1 *SignatureRequest_GenericSignerOptions `protobuf:"bytes,5,opt,name=signerOptsRSAPKCS1,proto3,oneof" json:"signerOptsRSAPKCS1,omitempty"`
}
type SignatureRequest_SignerOptsRSAPSS struct {
	SignerOptsRSAPSS *SignatureRequest_RSAPSSOptions `protobuf:"bytes,6,opt,name=signerOptsRSAPSS,proto3,oneof" json:"signerOptsRSAPSS,omitempty"`
}
type SignatureRequest_SignerOptsECDSA struct {
	SignerOptsECDSA *SignatureRequest_GenericSignerOptions `protobuf:"bytes,7,opt,name=signerOptsECDSA,proto3,oneof" json:"signerOptsECDSA,omitempty"`
}
type SignatureRequest_SignerOptsED25519 struct {
	SignerOptsED25519 *SignatureRequest_GenericSignerOptions `protobuf:"bytes,8,opt,name=signerOptsED25519,proto3,oneof" json:"signerOptsED25519,omitempty"`
}

func (*SignatureRequest_SignerOptsRSAPKCS1) isSignatureRequest_SignerOpts() {}
func (*SignatureRequest_SignerOptsRSAPSS) isSignatureRequest_SignerOpts()   {}
func (*SignatureRequest_SignerOptsECDSA) isSignatureRequest_SignerOpts()    {}
func (*SignatureRequest_SignerOptsED25519) isSignatureRequest_SignerOpts()  {}

func (m *SignatureRequest) GetSignerOpts() isSignatureRequest_SignerOpts {
	if m != nil {
		return m.SignerOpts
	}
	return nil
}

func (m *SignatureRequest) GetVersion() Version {
	if m != nil {
		return m.Version
	}
	return Version_v1alpha1
}

func (m *SignatureRequest) GetCluster() *Cluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *SignatureRequest) GetConfiguration() map[string]string {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *SignatureRequest) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *SignatureRequest) GetSignerOptsRSAPKCS1() *SignatureRequest_GenericSignerOptions {
	if x, ok := m.GetSignerOpts().(*SignatureRequest_SignerOptsRSAPKCS1); ok {
		return x.SignerOptsRSAPKCS1
	}
	return nil
}

func (m *SignatureRequest) GetSignerOptsRSAPSS() *SignatureRequest_RSAPSSOptions {
	if x, ok := m.GetSignerOpts().(*SignatureRequest_SignerOptsRSAPSS); ok {
		return x.SignerOptsRSAPSS
	}
	return nil
}

func (m *SignatureRequest) GetSignerOptsECDSA() *SignatureRequest_GenericSignerOptions {
	if x, ok := m.GetSignerOpts().(*SignatureRequest_SignerOptsECDSA); ok {
		return x.SignerOptsECDSA
	}
	return nil
}

func (m *SignatureRequest) GetSignerOptsED25519() *SignatureRequest_GenericSignerOptions {
	if x, ok := m.GetSignerOpts().(*SignatureRequest_SignerOptsED25519); ok {
		return x.SignerOptsED25519
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignatureRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignatureRequest_SignerOptsRSAPKCS1)(nil),
		(*SignatureRequest_SignerOptsRSAPSS)(nil),
		(*SignatureRequest_SignerOptsECDSA)(nil),
		(*SignatureRequest_SignerOptsED25519)(nil),
	}
}

// Definition of options for creating the PSS signature.
type SignatureRequest_RSAPSSOptions struct {
	// Length of the salt for creating the PSS signature.
	SaltLenght int32 `protobuf:"varint,1,opt,name=saltLenght,proto3" json:"saltLenght,omitempty"`
	// Hash function for creating the PSS signature.
	Hash                 uint32   `protobuf:"varint,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignatureRequest_RSAPSSOptions) Reset()         { *m = SignatureRequest_RSAPSSOptions{} }
func (m *SignatureRequest_RSAPSSOptions) String() string { return proto.CompactTextString(m) }
func (*SignatureRequest_RSAPSSOptions) ProtoMessage()    {}
func (*SignatureRequest_RSAPSSOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{5, 1}
}
func (m *SignatureRequest_RSAPSSOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureRequest_RSAPSSOptions.Unmarshal(m, b)
}
func (m *SignatureRequest_RSAPSSOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureRequest_RSAPSSOptions.Marshal(b, m, deterministic)
}
func (m *SignatureRequest_RSAPSSOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureRequest_RSAPSSOptions.Merge(m, src)
}
func (m *SignatureRequest_RSAPSSOptions) XXX_Size() int {
	return xxx_messageInfo_SignatureRequest_RSAPSSOptions.Size(m)
}
func (m *SignatureRequest_RSAPSSOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureRequest_RSAPSSOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureRequest_RSAPSSOptions proto.InternalMessageInfo

func (m *SignatureRequest_RSAPSSOptions) GetSaltLenght() int32 {
	if m != nil {
		return m.SaltLenght
	}
	return 0
}

func (m *SignatureRequest_RSAPSSOptions) GetHash() uint32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

// Definition of options for creating the generic signature.
type SignatureRequest_GenericSignerOptions struct {
	// Hash function for creating the generic signature.
	Hash                 uint32   `protobuf:"varint,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignatureRequest_GenericSignerOptions) Reset()         { *m = SignatureRequest_GenericSignerOptions{} }
func (m *SignatureRequest_GenericSignerOptions) String() string { return proto.CompactTextString(m) }
func (*SignatureRequest_GenericSignerOptions) ProtoMessage()    {}
func (*SignatureRequest_GenericSignerOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{5, 2}
}
func (m *SignatureRequest_GenericSignerOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureRequest_GenericSignerOptions.Unmarshal(m, b)
}
func (m *SignatureRequest_GenericSignerOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureRequest_GenericSignerOptions.Marshal(b, m, deterministic)
}
func (m *SignatureRequest_GenericSignerOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureRequest_GenericSignerOptions.Merge(m, src)
}
func (m *SignatureRequest_GenericSignerOptions) XXX_Size() int {
	return xxx_messageInfo_SignatureRequest_GenericSignerOptions.Size(m)
}
func (m *SignatureRequest_GenericSignerOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureRequest_GenericSignerOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureRequest_GenericSignerOptions proto.InternalMessageInfo

func (m *SignatureRequest_GenericSignerOptions) GetHash() uint32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

type SignatureResponse struct {
	// Types that are valid to be assigned to Content:
	//	*SignatureResponse_Signature
	//	*SignatureResponse_UserPrompt
	Content              isSignatureResponse_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SignatureResponse) Reset()         { *m = SignatureResponse{} }
func (m *SignatureResponse) String() string { return proto.CompactTextString(m) }
func (*SignatureResponse) ProtoMessage()    {}
func (*SignatureResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{6}
}
func (m *SignatureResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureResponse.Unmarshal(m, b)
}
func (m *SignatureResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureResponse.Marshal(b, m, deterministic)
}
func (m *SignatureResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureResponse.Merge(m, src)
}
func (m *SignatureResponse) XXX_Size() int {
	return xxx_messageInfo_SignatureResponse.Size(m)
}
func (m *SignatureResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureResponse proto.InternalMessageInfo

type isSignatureResponse_Content interface {
	isSignatureResponse_Content()
}

type SignatureResponse_Signature struct {
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3,oneof" json:"signature,omitempty"`
}
type SignatureResponse_UserPrompt struct {
	UserPrompt string `protobuf:"bytes,2,opt,name=userPrompt,proto3,oneof" json:"userPrompt,omitempty"`
}

func (*SignatureResponse_Signature) isSignatureResponse_Content()  {}
func (*SignatureResponse_UserPrompt) isSignatureResponse_Content() {}

func (m *SignatureResponse) GetContent() isSignatureResponse_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *SignatureResponse) GetSignature() []byte {
	if x, ok := m.GetContent().(*SignatureResponse_Signature); ok {
		return x.Signature
	}
	return nil
}

func (m *SignatureResponse) GetUserPrompt() string {
	if x, ok := m.GetContent().(*SignatureResponse_UserPrompt); ok {
		return x.UserPrompt
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignatureResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignatureResponse_Signature)(nil),
		(*SignatureResponse_UserPrompt)(nil),
	}
}

func init() {
	proto.RegisterEnum("v1alpha1.Version", Version_name, Version_value)
	proto.RegisterType((*VersionRequest)(nil), "v1alpha1.VersionRequest")
	proto.RegisterType((*VersionResponse)(nil), "v1alpha1.VersionResponse")
	proto.RegisterType((*Cluster)(nil), "v1alpha1.Cluster")
	proto.RegisterType((*CertificateRequest)(nil), "v1alpha1.CertificateRequest")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.CertificateRequest.ConfigurationEntry")
	proto.RegisterType((*CertificateResponse)(nil), "v1alpha1.CertificateResponse")
	proto.RegisterType((*SignatureRequest)(nil), "v1alpha1.SignatureRequest")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.SignatureRequest.ConfigurationEntry")
	proto.RegisterType((*SignatureRequest_RSAPSSOptions)(nil), "v1alpha1.SignatureRequest.RSAPSSOptions")
	proto.RegisterType((*SignatureRequest_GenericSignerOptions)(nil), "v1alpha1.SignatureRequest.GenericSignerOptions")
	proto.RegisterType((*SignatureResponse)(nil), "v1alpha1.SignatureResponse")
}

func init() { proto.RegisterFile("service.proto", fileDescriptor_a0b84a42fa06f626) }

var fileDescriptor_a0b84a42fa06f626 = []byte{
	// 615 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xdf, 0x6e, 0xd3, 0x3e,
	0x14, 0x6e, 0xd6, 0x7f, 0xeb, 0xe9, 0x9f, 0xb5, 0xfe, 0xed, 0x07, 0x21, 0xc0, 0x54, 0xe5, 0xaa,
	0x1a, 0xa2, 0xa3, 0x45, 0x93, 0x00, 0x09, 0xb4, 0x2d, 0xad, 0x56, 0x09, 0x04, 0x23, 0x11, 0xbb,
	0xe1, 0x02, 0x4c, 0x70, 0xdb, 0x88, 0xce, 0xe9, 0x6c, 0xa7, 0x62, 0x4f, 0xc0, 0x03, 0xf0, 0xa4,
	0xbc, 0x01, 0x8a, 0x9d, 0x34, 0xe9, 0xda, 0x15, 0xad, 0x48, 0xdc, 0xf9, 0x7c, 0xfe, 0xce, 0x77,
	0x3e, 0x9f, 0xf8, 0x38, 0x50, 0xe5, 0x84, 0xcd, 0x3c, 0x97, 0xb4, 0xa7, 0xcc, 0x17, 0x3e, 0xda,
	0x9e, 0x75, 0xf0, 0x64, 0x3a, 0xc6, 0x1d, 0xf3, 0x25, 0xd4, 0xce, 0x09, 0xe3, 0x9e, 0x4f, 0x6d,
	0x72, 0x19, 0x10, 0x2e, 0xd0, 0x23, 0x28, 0xce, 0x14, 0xa2, 0x6b, 0x4d, 0xad, 0x55, 0xeb, 0x36,
	0xda, 0x31, 0xbb, 0x1d, 0x53, 0x63, 0x86, 0xf9, 0x0a, 0x76, 0xe6, 0xe9, 0x7c, 0xea, 0x53, 0x4e,
	0x6e, 0x97, 0x7f, 0x09, 0x45, 0x6b, 0x12, 0x70, 0x41, 0x18, 0xba, 0x03, 0x85, 0xd0, 0x24, 0x61,
	0x32, 0xad, 0x64, 0x47, 0x11, 0xda, 0x03, 0x50, 0xab, 0xb7, 0xf8, 0x82, 0xe8, 0x5b, 0x72, 0x2f,
	0x85, 0x84, 0x79, 0x2e, 0xee, 0x61, 0x81, 0xf5, 0x6c, 0x53, 0x6b, 0x55, 0xec, 0x28, 0x92, 0xb8,
	0x4f, 0x87, 0xde, 0x48, 0xcf, 0x45, 0xb8, 0x8c, 0xcc, 0x1f, 0x5b, 0x80, 0x2c, 0xc2, 0x84, 0x37,
	0xf4, 0x5c, 0x2c, 0xc8, 0x26, 0xc7, 0x0e, 0xc9, 0xae, 0xb2, 0x2d, 0x0d, 0x95, 0xd3, 0xe4, 0xe8,
	0x3c, 0x76, 0xcc, 0x40, 0x1f, 0xa0, 0xaa, 0x4a, 0x07, 0x0c, 0x8b, 0x50, 0x3f, 0xdb, 0xcc, 0xb6,
	0xca, 0xdd, 0x83, 0x54, 0xca, 0x92, 0x9d, 0xb6, 0x95, 0xce, 0xe8, 0x53, 0xc1, 0xae, 0xec, 0x45,
	0x15, 0xe3, 0x08, 0xd0, 0x32, 0x09, 0xd5, 0x21, 0xfb, 0x8d, 0x5c, 0x45, 0x2d, 0x0c, 0x97, 0x68,
	0x17, 0xf2, 0x33, 0x3c, 0x09, 0xe2, 0xd6, 0xa9, 0xe0, 0xc5, 0xd6, 0x33, 0xcd, 0x1c, 0xc2, 0x7f,
	0x0b, 0x95, 0xa3, 0x0f, 0x68, 0x42, 0xd9, 0x4d, 0x60, 0x29, 0x55, 0x19, 0x64, 0xec, 0x34, 0x88,
	0x9a, 0x00, 0x01, 0x27, 0xec, 0x8c, 0xf9, 0x17, 0x53, 0xa1, 0x94, 0x07, 0x19, 0x3b, 0x85, 0x9d,
	0x94, 0xa0, 0xe8, 0xfa, 0x54, 0x10, 0x2a, 0xcc, 0x9f, 0x05, 0xa8, 0x3b, 0xde, 0x88, 0x62, 0x11,
	0xb0, 0x7f, 0xd0, 0x6f, 0x67, 0x75, 0xbf, 0x1f, 0x27, 0x29, 0xd7, 0xcd, 0xfc, 0xb9, 0xdb, 0xe1,
	0x6d, 0xfa, 0xea, 0x8d, 0x08, 0x17, 0xf1, 0x6d, 0x52, 0x11, 0xc2, 0x80, 0xb8, 0x37, 0xa2, 0x84,
	0xbd, 0x9b, 0x0a, 0x6e, 0x3b, 0xc7, 0x67, 0xaf, 0x2d, 0xa7, 0xa3, 0xe7, 0xa5, 0xc9, 0x83, 0x35,
	0x15, 0x4f, 0x09, 0x25, 0xcc, 0x73, 0x9d, 0x38, 0xd7, 0xf3, 0x29, 0x1f, 0x64, 0xec, 0x15, 0x62,
	0xe8, 0x1c, 0xea, 0x8b, 0xa8, 0xe3, 0xe8, 0x05, 0x59, 0xa0, 0xb5, 0xa6, 0x80, 0x22, 0x26, 0xca,
	0x4b, 0x1a, 0xe8, 0x23, 0xec, 0x24, 0x58, 0xdf, 0xea, 0x39, 0xc7, 0x7a, 0x71, 0x53, 0xdf, 0xd7,
	0x95, 0xd0, 0x27, 0x68, 0xa4, 0xa0, 0x5e, 0xf7, 0xf0, 0xb0, 0xf3, 0x5c, 0xdf, 0xde, 0x54, 0x7e,
	0x59, 0xeb, 0xef, 0xaf, 0xbf, 0x61, 0x41, 0x75, 0xa1, 0x49, 0xf2, 0xa5, 0xc1, 0x13, 0xf1, 0x86,
	0xd0, 0xd1, 0x58, 0x48, 0x8d, 0xbc, 0x9d, 0x42, 0x10, 0x82, 0xdc, 0x18, 0xf3, 0xb1, 0x54, 0xaa,
	0xda, 0x72, 0x6d, 0xec, 0xc3, 0xee, 0x2a, 0xcf, 0x73, 0xae, 0x96, 0x70, 0x4f, 0x2a, 0x00, 0xc9,
	0x39, 0xcc, 0xcf, 0xd0, 0x48, 0x1d, 0x3f, 0x9a, 0xbd, 0x3d, 0x28, 0xf1, 0x18, 0x9c, 0x4f, 0x5e,
	0x02, 0xdd, 0x6a, 0xee, 0xf6, 0xef, 0x42, 0x31, 0x9a, 0x24, 0x54, 0x81, 0xf9, 0x93, 0x5f, 0xcf,
	0x74, 0x7f, 0x69, 0xf0, 0x7f, 0xff, 0xbb, 0x20, 0x8c, 0xe2, 0x89, 0xb2, 0xed, 0xa8, 0xdf, 0x03,
	0x3a, 0x4a, 0x52, 0xf4, 0xe5, 0x79, 0x54, 0x1f, 0xc9, 0xb8, 0xb7, 0x62, 0x47, 0xf9, 0x37, 0x33,
	0xe8, 0x3d, 0xd4, 0x4e, 0x89, 0x48, 0xbd, 0x2b, 0xe8, 0xc1, 0xba, 0x87, 0xce, 0x78, 0x78, 0xc3,
	0x6e, 0x2c, 0xf8, 0x44, 0x43, 0x16, 0xe4, 0x42, 0x97, 0xc8, 0xb8, 0xf9, 0xe2, 0x18, 0xf7, 0x57,
	0xee, 0x25, 0x22, 0x5f, 0x0a, 0xf2, 0xcf, 0xf7, 0xf4, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4a,
	0xfd, 0x7f, 0xb2, 0x0a, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExternalSignerServiceClient is the client API for ExternalSignerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExternalSignerServiceClient interface {
	// Version returns the version of the external signer plugin.
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	// Get certificate from the external signer.
	GetCertificate(ctx context.Context, in *CertificateRequest, opts ...grpc.CallOption) (ExternalSignerService_GetCertificateClient, error)
	// Execute signing operation in the external signer plugin.
	Sign(ctx context.Context, in *SignatureRequest, opts ...grpc.CallOption) (ExternalSignerService_SignClient, error)
}

type externalSignerServiceClient struct {
	cc *grpc.ClientConn
}

func NewExternalSignerServiceClient(cc *grpc.ClientConn) ExternalSignerServiceClient {
	return &externalSignerServiceClient{cc}
}

func (c *externalSignerServiceClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/v1alpha1.ExternalSignerService/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalSignerServiceClient) GetCertificate(ctx context.Context, in *CertificateRequest, opts ...grpc.CallOption) (ExternalSignerService_GetCertificateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExternalSignerService_serviceDesc.Streams[0], "/v1alpha1.ExternalSignerService/GetCertificate", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalSignerServiceGetCertificateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalSignerService_GetCertificateClient interface {
	Recv() (*CertificateResponse, error)
	grpc.ClientStream
}

type externalSignerServiceGetCertificateClient struct {
	grpc.ClientStream
}

func (x *externalSignerServiceGetCertificateClient) Recv() (*CertificateResponse, error) {
	m := new(CertificateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *externalSignerServiceClient) Sign(ctx context.Context, in *SignatureRequest, opts ...grpc.CallOption) (ExternalSignerService_SignClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExternalSignerService_serviceDesc.Streams[1], "/v1alpha1.ExternalSignerService/Sign", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalSignerServiceSignClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalSignerService_SignClient interface {
	Recv() (*SignatureResponse, error)
	grpc.ClientStream
}

type externalSignerServiceSignClient struct {
	grpc.ClientStream
}

func (x *externalSignerServiceSignClient) Recv() (*SignatureResponse, error) {
	m := new(SignatureResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExternalSignerServiceServer is the server API for ExternalSignerService service.
type ExternalSignerServiceServer interface {
	// Version returns the version of the external signer plugin.
	Version(context.Context, *VersionRequest) (*VersionResponse, error)
	// Get certificate from the external signer.
	GetCertificate(*CertificateRequest, ExternalSignerService_GetCertificateServer) error
	// Execute signing operation in the external signer plugin.
	Sign(*SignatureRequest, ExternalSignerService_SignServer) error
}

// UnimplementedExternalSignerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedExternalSignerServiceServer struct {
}

func (*UnimplementedExternalSignerServiceServer) Version(ctx context.Context, req *VersionRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (*UnimplementedExternalSignerServiceServer) GetCertificate(req *CertificateRequest, srv ExternalSignerService_GetCertificateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCertificate not implemented")
}
func (*UnimplementedExternalSignerServiceServer) Sign(req *SignatureRequest, srv ExternalSignerService_SignServer) error {
	return status.Errorf(codes.Unimplemented, "method Sign not implemented")
}

func RegisterExternalSignerServiceServer(s *grpc.Server, srv ExternalSignerServiceServer) {
	s.RegisterService(&_ExternalSignerService_serviceDesc, srv)
}

func _ExternalSignerService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalSignerServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha1.ExternalSignerService/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalSignerServiceServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalSignerService_GetCertificate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CertificateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalSignerServiceServer).GetCertificate(m, &externalSignerServiceGetCertificateServer{stream})
}

type ExternalSignerService_GetCertificateServer interface {
	Send(*CertificateResponse) error
	grpc.ServerStream
}

type externalSignerServiceGetCertificateServer struct {
	grpc.ServerStream
}

func (x *externalSignerServiceGetCertificateServer) Send(m *CertificateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ExternalSignerService_Sign_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SignatureRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalSignerServiceServer).Sign(m, &externalSignerServiceSignServer{stream})
}

type ExternalSignerService_SignServer interface {
	Send(*SignatureResponse) error
	grpc.ServerStream
}

type externalSignerServiceSignServer struct {
	grpc.ServerStream
}

func (x *externalSignerServiceSignServer) Send(m *SignatureResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ExternalSignerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1alpha1.ExternalSignerService",
	HandlerType: (*ExternalSignerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _ExternalSignerService_Version_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetCertificate",
			Handler:       _ExternalSignerService_GetCertificate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Sign",
			Handler:       _ExternalSignerService_Sign_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}
