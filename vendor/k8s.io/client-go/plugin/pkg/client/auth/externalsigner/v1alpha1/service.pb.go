/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: service.proto

// package externalsigner;

package v1alpha1

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Enumeration of supported signer types.
type SignatureRequest_SignerType int32

const (
	SignatureRequest_RSAPSS SignatureRequest_SignerType = 0
)

var SignatureRequest_SignerType_name = map[int32]string{
	0: "RSAPSS",
}

var SignatureRequest_SignerType_value = map[string]int32{
	"RSAPSS": 0,
}

func (x SignatureRequest_SignerType) String() string {
	return proto.EnumName(SignatureRequest_SignerType_name, int32(x))
}

func (SignatureRequest_SignerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{4, 0}
}

type VersionRequest struct {
	// Version of the external signer plugin API.
	Version              string   `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionRequest) Reset()         { *m = VersionRequest{} }
func (m *VersionRequest) String() string { return proto.CompactTextString(m) }
func (*VersionRequest) ProtoMessage()    {}
func (*VersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{0}
}
func (m *VersionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionRequest.Unmarshal(m, b)
}
func (m *VersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionRequest.Marshal(b, m, deterministic)
}
func (m *VersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionRequest.Merge(m, src)
}
func (m *VersionRequest) XXX_Size() int {
	return xxx_messageInfo_VersionRequest.Size(m)
}
func (m *VersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VersionRequest proto.InternalMessageInfo

func (m *VersionRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type VersionResponse struct {
	// Version of the external signer plugin API.
	Version              string   `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionResponse) Reset()         { *m = VersionResponse{} }
func (m *VersionResponse) String() string { return proto.CompactTextString(m) }
func (*VersionResponse) ProtoMessage()    {}
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{1}
}
func (m *VersionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionResponse.Unmarshal(m, b)
}
func (m *VersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionResponse.Marshal(b, m, deterministic)
}
func (m *VersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionResponse.Merge(m, src)
}
func (m *VersionResponse) XXX_Size() int {
	return xxx_messageInfo_VersionResponse.Size(m)
}
func (m *VersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VersionResponse proto.InternalMessageInfo

func (m *VersionResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type CertificateRequest struct {
	// Version of the external signer plugin API.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Name of the Kubernetes cluster.
	ClusterName string `protobuf:"bytes,2,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	// Configuration of the external signer plugin. This configuration is specific to the external signer, but stored in KUBECONFIG for the user's convenience to allow multiplexing a single external signer for several K8s users.
	Configuration        map[string]string `protobuf:"bytes,3,rep,name=configuration,proto3" json:"configuration,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CertificateRequest) Reset()         { *m = CertificateRequest{} }
func (m *CertificateRequest) String() string { return proto.CompactTextString(m) }
func (*CertificateRequest) ProtoMessage()    {}
func (*CertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{2}
}
func (m *CertificateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateRequest.Unmarshal(m, b)
}
func (m *CertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateRequest.Marshal(b, m, deterministic)
}
func (m *CertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateRequest.Merge(m, src)
}
func (m *CertificateRequest) XXX_Size() int {
	return xxx_messageInfo_CertificateRequest.Size(m)
}
func (m *CertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateRequest proto.InternalMessageInfo

func (m *CertificateRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CertificateRequest) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *CertificateRequest) GetConfiguration() map[string]string {
	if m != nil {
		return m.Configuration
	}
	return nil
}

type CertificateResponse struct {
	// Types that are valid to be assigned to Content:
	//	*CertificateResponse_Certificate
	//	*CertificateResponse_UserPrompt
	Content              isCertificateResponse_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *CertificateResponse) Reset()         { *m = CertificateResponse{} }
func (m *CertificateResponse) String() string { return proto.CompactTextString(m) }
func (*CertificateResponse) ProtoMessage()    {}
func (*CertificateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{3}
}
func (m *CertificateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateResponse.Unmarshal(m, b)
}
func (m *CertificateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateResponse.Marshal(b, m, deterministic)
}
func (m *CertificateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateResponse.Merge(m, src)
}
func (m *CertificateResponse) XXX_Size() int {
	return xxx_messageInfo_CertificateResponse.Size(m)
}
func (m *CertificateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateResponse proto.InternalMessageInfo

type isCertificateResponse_Content interface {
	isCertificateResponse_Content()
}

type CertificateResponse_Certificate struct {
	Certificate []byte `protobuf:"bytes,1,opt,name=certificate,proto3,oneof" json:"certificate,omitempty"`
}
type CertificateResponse_UserPrompt struct {
	UserPrompt string `protobuf:"bytes,2,opt,name=userPrompt,proto3,oneof" json:"userPrompt,omitempty"`
}

func (*CertificateResponse_Certificate) isCertificateResponse_Content() {}
func (*CertificateResponse_UserPrompt) isCertificateResponse_Content()  {}

func (m *CertificateResponse) GetContent() isCertificateResponse_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *CertificateResponse) GetCertificate() []byte {
	if x, ok := m.GetContent().(*CertificateResponse_Certificate); ok {
		return x.Certificate
	}
	return nil
}

func (m *CertificateResponse) GetUserPrompt() string {
	if x, ok := m.GetContent().(*CertificateResponse_UserPrompt); ok {
		return x.UserPrompt
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CertificateResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CertificateResponse_Certificate)(nil),
		(*CertificateResponse_UserPrompt)(nil),
	}
}

type SignatureRequest struct {
	// Version of the external signer plugin API.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Name of the Kubernetes cluster.
	ClusterName string `protobuf:"bytes,2,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	// Configuration of the external signer plugin (HSM protocol specific).
	Configuration map[string]string `protobuf:"bytes,3,rep,name=configuration,proto3" json:"configuration,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Digest to be signed.
	Digest []byte `protobuf:"bytes,4,opt,name=digest,proto3" json:"digest,omitempty"`
	// Type of signer.
	SignerType SignatureRequest_SignerType `protobuf:"varint,5,opt,name=signerType,proto3,enum=v1alpha1.SignatureRequest_SignerType" json:"signerType,omitempty"`
	// Options for creating the PSS signature (used when signerType is set to RSAPSS).
	SignerOptsRSAPSS     *SignatureRequest_RSAPSSOptions `protobuf:"bytes,6,opt,name=signerOptsRSAPSS,proto3" json:"signerOptsRSAPSS,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *SignatureRequest) Reset()         { *m = SignatureRequest{} }
func (m *SignatureRequest) String() string { return proto.CompactTextString(m) }
func (*SignatureRequest) ProtoMessage()    {}
func (*SignatureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{4}
}
func (m *SignatureRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureRequest.Unmarshal(m, b)
}
func (m *SignatureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureRequest.Marshal(b, m, deterministic)
}
func (m *SignatureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureRequest.Merge(m, src)
}
func (m *SignatureRequest) XXX_Size() int {
	return xxx_messageInfo_SignatureRequest.Size(m)
}
func (m *SignatureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureRequest proto.InternalMessageInfo

func (m *SignatureRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SignatureRequest) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *SignatureRequest) GetConfiguration() map[string]string {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *SignatureRequest) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *SignatureRequest) GetSignerType() SignatureRequest_SignerType {
	if m != nil {
		return m.SignerType
	}
	return SignatureRequest_RSAPSS
}

func (m *SignatureRequest) GetSignerOptsRSAPSS() *SignatureRequest_RSAPSSOptions {
	if m != nil {
		return m.SignerOptsRSAPSS
	}
	return nil
}

// Definition of options for creating the PSS signature.
type SignatureRequest_RSAPSSOptions struct {
	// Length of the salt for creating the PSS signature.
	SaltLenght int32 `protobuf:"varint,1,opt,name=saltLenght,proto3" json:"saltLenght,omitempty"`
	// Hash function for creating the PSS signature.
	Hash                 uint32   `protobuf:"varint,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignatureRequest_RSAPSSOptions) Reset()         { *m = SignatureRequest_RSAPSSOptions{} }
func (m *SignatureRequest_RSAPSSOptions) String() string { return proto.CompactTextString(m) }
func (*SignatureRequest_RSAPSSOptions) ProtoMessage()    {}
func (*SignatureRequest_RSAPSSOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{4, 1}
}
func (m *SignatureRequest_RSAPSSOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureRequest_RSAPSSOptions.Unmarshal(m, b)
}
func (m *SignatureRequest_RSAPSSOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureRequest_RSAPSSOptions.Marshal(b, m, deterministic)
}
func (m *SignatureRequest_RSAPSSOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureRequest_RSAPSSOptions.Merge(m, src)
}
func (m *SignatureRequest_RSAPSSOptions) XXX_Size() int {
	return xxx_messageInfo_SignatureRequest_RSAPSSOptions.Size(m)
}
func (m *SignatureRequest_RSAPSSOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureRequest_RSAPSSOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureRequest_RSAPSSOptions proto.InternalMessageInfo

func (m *SignatureRequest_RSAPSSOptions) GetSaltLenght() int32 {
	if m != nil {
		return m.SaltLenght
	}
	return 0
}

func (m *SignatureRequest_RSAPSSOptions) GetHash() uint32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

type SignatureResponse struct {
	// Types that are valid to be assigned to Content:
	//	*SignatureResponse_Signature
	//	*SignatureResponse_UserPrompt
	Content              isSignatureResponse_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SignatureResponse) Reset()         { *m = SignatureResponse{} }
func (m *SignatureResponse) String() string { return proto.CompactTextString(m) }
func (*SignatureResponse) ProtoMessage()    {}
func (*SignatureResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{5}
}
func (m *SignatureResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureResponse.Unmarshal(m, b)
}
func (m *SignatureResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureResponse.Marshal(b, m, deterministic)
}
func (m *SignatureResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureResponse.Merge(m, src)
}
func (m *SignatureResponse) XXX_Size() int {
	return xxx_messageInfo_SignatureResponse.Size(m)
}
func (m *SignatureResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureResponse proto.InternalMessageInfo

type isSignatureResponse_Content interface {
	isSignatureResponse_Content()
}

type SignatureResponse_Signature struct {
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3,oneof" json:"signature,omitempty"`
}
type SignatureResponse_UserPrompt struct {
	UserPrompt string `protobuf:"bytes,2,opt,name=userPrompt,proto3,oneof" json:"userPrompt,omitempty"`
}

func (*SignatureResponse_Signature) isSignatureResponse_Content()  {}
func (*SignatureResponse_UserPrompt) isSignatureResponse_Content() {}

func (m *SignatureResponse) GetContent() isSignatureResponse_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *SignatureResponse) GetSignature() []byte {
	if x, ok := m.GetContent().(*SignatureResponse_Signature); ok {
		return x.Signature
	}
	return nil
}

func (m *SignatureResponse) GetUserPrompt() string {
	if x, ok := m.GetContent().(*SignatureResponse_UserPrompt); ok {
		return x.UserPrompt
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignatureResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignatureResponse_Signature)(nil),
		(*SignatureResponse_UserPrompt)(nil),
	}
}

type SubscribeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{6}
}
func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeRequest.Unmarshal(m, b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(m, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeRequest.Size(m)
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

type PromptsResponse struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PromptsResponse) Reset()         { *m = PromptsResponse{} }
func (m *PromptsResponse) String() string { return proto.CompactTextString(m) }
func (*PromptsResponse) ProtoMessage()    {}
func (*PromptsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{7}
}
func (m *PromptsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PromptsResponse.Unmarshal(m, b)
}
func (m *PromptsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PromptsResponse.Marshal(b, m, deterministic)
}
func (m *PromptsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PromptsResponse.Merge(m, src)
}
func (m *PromptsResponse) XXX_Size() int {
	return xxx_messageInfo_PromptsResponse.Size(m)
}
func (m *PromptsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PromptsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PromptsResponse proto.InternalMessageInfo

func (m *PromptsResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("v1alpha1.SignatureRequest_SignerType", SignatureRequest_SignerType_name, SignatureRequest_SignerType_value)
	proto.RegisterType((*VersionRequest)(nil), "v1alpha1.VersionRequest")
	proto.RegisterType((*VersionResponse)(nil), "v1alpha1.VersionResponse")
	proto.RegisterType((*CertificateRequest)(nil), "v1alpha1.CertificateRequest")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.CertificateRequest.ConfigurationEntry")
	proto.RegisterType((*CertificateResponse)(nil), "v1alpha1.CertificateResponse")
	proto.RegisterType((*SignatureRequest)(nil), "v1alpha1.SignatureRequest")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.SignatureRequest.ConfigurationEntry")
	proto.RegisterType((*SignatureRequest_RSAPSSOptions)(nil), "v1alpha1.SignatureRequest.RSAPSSOptions")
	proto.RegisterType((*SignatureResponse)(nil), "v1alpha1.SignatureResponse")
	proto.RegisterType((*SubscribeRequest)(nil), "v1alpha1.SubscribeRequest")
	proto.RegisterType((*PromptsResponse)(nil), "v1alpha1.PromptsResponse")
}

func init() { proto.RegisterFile("service.proto", fileDescriptor_a0b84a42fa06f626) }

var fileDescriptor_a0b84a42fa06f626 = []byte{
	// 528 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x8f, 0xd2, 0x50,
	0x10, 0xa7, 0xcb, 0x02, 0x32, 0x08, 0xe2, 0xf8, 0x91, 0x5a, 0x75, 0xd3, 0x34, 0x31, 0x21, 0x1a,
	0xd1, 0xc5, 0x8b, 0xf1, 0xb4, 0x4a, 0x88, 0x7b, 0x30, 0xee, 0xfa, 0xba, 0x7a, 0xf6, 0x51, 0x87,
	0xd2, 0x58, 0xda, 0xfa, 0xde, 0x2b, 0x91, 0x3f, 0xd9, 0xa3, 0x47, 0x6f, 0xa6, 0x5f, 0xb4, 0x08,
	0xcb, 0xc6, 0xe8, 0xad, 0xf3, 0x9b, 0x79, 0xbf, 0xf9, 0xe8, 0x6f, 0x06, 0xba, 0x92, 0xc4, 0xd2,
	0x73, 0x68, 0x18, 0x89, 0x50, 0x85, 0x78, 0x6d, 0x79, 0xcc, 0xfd, 0x68, 0xce, 0x8f, 0xad, 0xc7,
	0xd0, 0xfb, 0x44, 0x42, 0x7a, 0x61, 0xc0, 0xe8, 0x5b, 0x4c, 0x52, 0xa1, 0x0e, 0xad, 0x65, 0x86,
	0xe8, 0x9a, 0xa9, 0x0d, 0xda, 0xac, 0x30, 0xad, 0x27, 0x70, 0x63, 0x1d, 0x2b, 0xa3, 0x30, 0x90,
	0xb4, 0x27, 0xf8, 0x87, 0x06, 0x38, 0x26, 0xa1, 0xbc, 0x99, 0xe7, 0x70, 0x45, 0x57, 0xb2, 0xa3,
	0x09, 0x1d, 0xc7, 0x8f, 0xa5, 0x22, 0xf1, 0x9e, 0x2f, 0x48, 0x3f, 0x48, 0xbd, 0x55, 0x08, 0x3f,
	0x42, 0xd7, 0x09, 0x83, 0x99, 0xe7, 0xc6, 0x82, 0xab, 0x84, 0xa1, 0x6e, 0xd6, 0x07, 0x9d, 0xd1,
	0xb3, 0x61, 0xd1, 0xcd, 0x70, 0x3b, 0xe1, 0x70, 0x5c, 0x7d, 0x31, 0x09, 0x94, 0x58, 0xb1, 0x4d,
	0x16, 0xe3, 0x04, 0x70, 0x3b, 0x08, 0xfb, 0x50, 0xff, 0x4a, 0xab, 0xbc, 0xc8, 0xe4, 0x13, 0x6f,
	0x43, 0x63, 0xc9, 0xfd, 0xb8, 0x28, 0x2d, 0x33, 0x5e, 0x1d, 0xbc, 0xd4, 0xac, 0x19, 0xdc, 0xda,
	0xc8, 0x9c, 0x0f, 0xc7, 0x82, 0x8e, 0x53, 0xc2, 0x29, 0xd5, 0xf5, 0xd3, 0x1a, 0xab, 0x82, 0x68,
	0x02, 0xc4, 0x92, 0xc4, 0xb9, 0x08, 0x17, 0x91, 0xca, 0x98, 0x4f, 0x6b, 0xac, 0x82, 0xbd, 0x69,
	0x43, 0xcb, 0x09, 0x03, 0x45, 0x81, 0xb2, 0x7e, 0xd5, 0xa1, 0x6f, 0x7b, 0x6e, 0xc0, 0x55, 0x2c,
	0xfe, 0xcb, 0x44, 0xed, 0xdd, 0x13, 0x7d, 0x5a, 0x4e, 0xf4, 0xcf, 0x74, 0x57, 0xcf, 0x13, 0xef,
	0x42, 0xf3, 0x8b, 0xe7, 0x92, 0x54, 0xfa, 0x61, 0xd2, 0x31, 0xcb, 0x2d, 0x9c, 0x00, 0x48, 0xcf,
	0x0d, 0x48, 0x5c, 0xac, 0x22, 0xd2, 0x1b, 0xa6, 0x36, 0xe8, 0x8d, 0x1e, 0xed, 0xc9, 0x64, 0xaf,
	0x83, 0x59, 0xe5, 0x21, 0x5e, 0x40, 0x3f, 0xb3, 0xce, 0x22, 0x25, 0x99, 0xfd, 0xfa, 0xdc, 0xb6,
	0xf5, 0xa6, 0xa9, 0x0d, 0x3a, 0xa3, 0xc1, 0x1e, 0xb2, 0x2c, 0xf0, 0x2c, 0x4a, 0x2a, 0x94, 0x6c,
	0x8b, 0xe1, 0xdf, 0x45, 0x60, 0x8c, 0xa1, 0xbb, 0x91, 0x04, 0x8f, 0x00, 0x24, 0xf7, 0xd5, 0x3b,
	0x0a, 0xdc, 0xb9, 0x4a, 0x39, 0x1a, 0xac, 0x82, 0x20, 0xc2, 0xe1, 0x9c, 0xcb, 0x79, 0xca, 0xd4,
	0x65, 0xe9, 0xb7, 0xa5, 0x03, 0x94, 0x6d, 0x23, 0x40, 0x33, 0xa3, 0xec, 0xd7, 0xac, 0xcf, 0x70,
	0xb3, 0xd2, 0x54, 0xae, 0xb0, 0x23, 0x68, 0xcb, 0x02, 0x5c, 0xeb, 0xab, 0x84, 0xfe, 0x4e, 0x5d,
	0x08, 0x7d, 0x3b, 0x9e, 0x4a, 0x47, 0x78, 0xd3, 0x62, 0x6c, 0xc9, 0xca, 0x67, 0x81, 0xb2, 0xba,
	0xf2, 0x0b, 0x92, 0x92, 0xbb, 0x54, 0xe8, 0x2d, 0x37, 0x47, 0x3f, 0x35, 0xb8, 0x33, 0xf9, 0xae,
	0x48, 0x04, 0xdc, 0xcf, 0xba, 0xb0, 0xb3, 0xab, 0x83, 0x27, 0xd0, 0xca, 0x2f, 0x07, 0xea, 0xe5,
	0x4f, 0xda, 0x3c, 0x3c, 0xc6, 0xbd, 0x1d, 0x9e, 0x2c, 0xa7, 0x55, 0xc3, 0x0f, 0xd0, 0x7b, 0x4b,
	0xaa, 0xb2, 0x65, 0xf8, 0x60, 0xdf, 0xda, 0x1b, 0x0f, 0x2f, 0xf1, 0x16, 0x84, 0xcf, 0x35, 0x1c,
	0xc3, 0x61, 0x52, 0x25, 0x1a, 0x97, 0xcb, 0xc6, 0xb8, 0xbf, 0xd3, 0x57, 0x92, 0x4c, 0x9b, 0xe9,
	0x41, 0x7d, 0xf1, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xdc, 0x0e, 0x36, 0x2c, 0x61, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExternalSignerServiceClient is the client API for ExternalSignerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExternalSignerServiceClient interface {
	// Version returns the version of the external signer plugin.
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	// Get certificate from the external signer.
	GetCertificate(ctx context.Context, in *CertificateRequest, opts ...grpc.CallOption) (ExternalSignerService_GetCertificateClient, error)
	// Execute signing operation in the external signer plugin.
	Sign(ctx context.Context, in *SignatureRequest, opts ...grpc.CallOption) (ExternalSignerService_SignClient, error)
}

type externalSignerServiceClient struct {
	cc *grpc.ClientConn
}

func NewExternalSignerServiceClient(cc *grpc.ClientConn) ExternalSignerServiceClient {
	return &externalSignerServiceClient{cc}
}

func (c *externalSignerServiceClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/v1alpha1.ExternalSignerService/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalSignerServiceClient) GetCertificate(ctx context.Context, in *CertificateRequest, opts ...grpc.CallOption) (ExternalSignerService_GetCertificateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExternalSignerService_serviceDesc.Streams[0], "/v1alpha1.ExternalSignerService/GetCertificate", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalSignerServiceGetCertificateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalSignerService_GetCertificateClient interface {
	Recv() (*CertificateResponse, error)
	grpc.ClientStream
}

type externalSignerServiceGetCertificateClient struct {
	grpc.ClientStream
}

func (x *externalSignerServiceGetCertificateClient) Recv() (*CertificateResponse, error) {
	m := new(CertificateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *externalSignerServiceClient) Sign(ctx context.Context, in *SignatureRequest, opts ...grpc.CallOption) (ExternalSignerService_SignClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExternalSignerService_serviceDesc.Streams[1], "/v1alpha1.ExternalSignerService/Sign", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalSignerServiceSignClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalSignerService_SignClient interface {
	Recv() (*SignatureResponse, error)
	grpc.ClientStream
}

type externalSignerServiceSignClient struct {
	grpc.ClientStream
}

func (x *externalSignerServiceSignClient) Recv() (*SignatureResponse, error) {
	m := new(SignatureResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExternalSignerServiceServer is the server API for ExternalSignerService service.
type ExternalSignerServiceServer interface {
	// Version returns the version of the external signer plugin.
	Version(context.Context, *VersionRequest) (*VersionResponse, error)
	// Get certificate from the external signer.
	GetCertificate(*CertificateRequest, ExternalSignerService_GetCertificateServer) error
	// Execute signing operation in the external signer plugin.
	Sign(*SignatureRequest, ExternalSignerService_SignServer) error
}

// UnimplementedExternalSignerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedExternalSignerServiceServer struct {
}

func (*UnimplementedExternalSignerServiceServer) Version(ctx context.Context, req *VersionRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (*UnimplementedExternalSignerServiceServer) GetCertificate(req *CertificateRequest, srv ExternalSignerService_GetCertificateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCertificate not implemented")
}
func (*UnimplementedExternalSignerServiceServer) Sign(req *SignatureRequest, srv ExternalSignerService_SignServer) error {
	return status.Errorf(codes.Unimplemented, "method Sign not implemented")
}

func RegisterExternalSignerServiceServer(s *grpc.Server, srv ExternalSignerServiceServer) {
	s.RegisterService(&_ExternalSignerService_serviceDesc, srv)
}

func _ExternalSignerService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalSignerServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha1.ExternalSignerService/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalSignerServiceServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalSignerService_GetCertificate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CertificateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalSignerServiceServer).GetCertificate(m, &externalSignerServiceGetCertificateServer{stream})
}

type ExternalSignerService_GetCertificateServer interface {
	Send(*CertificateResponse) error
	grpc.ServerStream
}

type externalSignerServiceGetCertificateServer struct {
	grpc.ServerStream
}

func (x *externalSignerServiceGetCertificateServer) Send(m *CertificateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ExternalSignerService_Sign_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SignatureRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalSignerServiceServer).Sign(m, &externalSignerServiceSignServer{stream})
}

type ExternalSignerService_SignServer interface {
	Send(*SignatureResponse) error
	grpc.ServerStream
}

type externalSignerServiceSignServer struct {
	grpc.ServerStream
}

func (x *externalSignerServiceSignServer) Send(m *SignatureResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ExternalSignerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1alpha1.ExternalSignerService",
	HandlerType: (*ExternalSignerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _ExternalSignerService_Version_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetCertificate",
			Handler:       _ExternalSignerService_GetCertificate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Sign",
			Handler:       _ExternalSignerService_Sign_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}
